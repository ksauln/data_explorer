from __future__ import annotations

import re
from dataclasses import dataclass

import duckdb
import pandas as pd

from src.llm_clients import LLMClient


@dataclass
class SQLPlan:
    sql: str
    rationale: str


def generate_sql_plan(
    question: str,
    *,
    schema_summary_text: str,
    dictionary_text: str,
    table_catalog_text: str,
    default_table_name: str,
    llm_client: LLMClient,
) -> SQLPlan:
    system_prompt = """
You are an expert analytics engineer.
Convert the user's question into one valid DuckDB SQL query using only the available tables provided.
Only use columns that exist in the schema summary.
Return response in this exact format:
Rationale: <one short sentence>
SQL: <single SQL statement>
""".strip()

    user_prompt = f"""
User question:
{question}

Dataset schema summary:
{schema_summary_text}

Data dictionary / join-key context:
{dictionary_text if dictionary_text.strip() else "None provided."}

Available tables:
{table_catalog_text}

Rules:
- Primary table is `{default_table_name}`.
- You may join other available tables when needed.
- Use SELECT-only query.
- If user asks for grouped/aggregated analysis, compute it directly in SQL.
- If the user asks for top/bottom ranking, include ORDER BY and LIMIT.
- If applying date_trunc or date logic to text/date-like columns, use TRY_CAST(column AS TIMESTAMP).
- Avoid SELECT * unless needed.
""".strip()

    response_text = llm_client.generate(system_prompt, user_prompt)
    sql = extract_sql(response_text)
    rationale = extract_rationale(response_text)
    return SQLPlan(sql=sql, rationale=rationale)


def extract_sql(response_text: str) -> str:
    fenced_match = re.search(r"```sql\s*(.*?)```", response_text, flags=re.IGNORECASE | re.DOTALL)
    if fenced_match:
        candidate = fenced_match.group(1).strip()
    else:
        sql_label_match = re.search(
            r"SQL:\s*(.*)",
            response_text,
            flags=re.IGNORECASE | re.DOTALL,
        )
        candidate = sql_label_match.group(1).strip() if sql_label_match else response_text.strip()

    candidate = candidate.replace("`", "").strip()
    if ";\n" in candidate:
        candidate = candidate.split(";\n")[0].strip() + ";"
    return candidate


def extract_rationale(response_text: str) -> str:
    match = re.search(r"Rationale:\s*(.*)", response_text, flags=re.IGNORECASE)
    if match:
        return match.group(1).strip()
    return "Generated by model."


def validate_sql(sql: str) -> None:
    if not sql:
        raise ValueError("Generated SQL is empty.")

    normalized = sql.strip().lower()
    if not (normalized.startswith("select") or normalized.startswith("with")):
        raise ValueError("Only SELECT/WITH queries are allowed.")

    blocked_patterns = [
        r"\binsert\b",
        r"\bupdate\b",
        r"\bdelete\b",
        r"\bdrop\b",
        r"\balter\b",
        r"\bcreate\b",
        r"\battach\b",
        r"\bcopy\b",
        r"\bpragma\b",
        r";.*\S",
    ]
    for pattern in blocked_patterns:
        if re.search(pattern, normalized, flags=re.IGNORECASE | re.DOTALL):
            raise ValueError("SQL contains blocked or unsafe statements.")


def run_sql_query(
    df: pd.DataFrame,
    sql: str,
    result_limit: int = 5000,
    additional_tables: dict[str, pd.DataFrame] | None = None,
    primary_table_name: str = "data",
) -> pd.DataFrame:
    validate_sql(sql)
    conn = duckdb.connect(database=":memory:")
    try:
        conn.register(primary_table_name, df)
        if primary_table_name != "data":
            conn.register("data", df)

        for table_name, table_df in (additional_tables or {}).items():
            if table_name in {primary_table_name, "data"}:
                continue
            conn.register(table_name, table_df)

        sql_text = sql.rstrip(";")
        try:
            relation = conn.sql(sql_text)
            return relation.limit(int(result_limit)).df()
        except Exception as exc:
            patched_sql = _patch_sql_for_common_datetime_issue(sql_text, str(exc))
            if patched_sql and patched_sql != sql_text:
                relation = conn.sql(patched_sql)
                return relation.limit(int(result_limit)).df()
            raise
    finally:
        conn.close()


def dataframe_to_text(df: pd.DataFrame, max_rows: int = 40) -> str:
    if df.empty:
        return "Query returned no rows."
    return df.head(max_rows).to_csv(index=False)


def _patch_sql_for_common_datetime_issue(sql: str, error_message: str) -> str | None:
    message = error_message.lower()
    if "date_trunc" not in message:
        return None
    if "varchar" not in message and "string" not in message:
        return None

    pattern = re.compile(
        r"date_trunc\s*\(\s*'([^']+)'\s*,\s*([^)]+?)\)",
        flags=re.IGNORECASE,
    )

    def _replace(match: re.Match[str]) -> str:
        unit = match.group(1)
        expression = match.group(2).strip()
        if "cast(" in expression.lower() or "try_cast(" in expression.lower():
            return match.group(0)
        return f"date_trunc('{unit}', try_cast({expression} AS TIMESTAMP))"

    patched = pattern.sub(_replace, sql)
    return patched if patched != sql else None
